### 内存对齐
[C/C++内存对齐详解](https://zhuanlan.zhihu.com/p/30007037)
[C/C++ 结构体及其数组的内存对齐](https://www.jianshu.com/p/666852837034)
现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

**内存对齐规则**
每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。**有效对齐值**也叫对齐单位。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) **结构体的总大小为 有效对齐值 的整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。
```C
#pragma pack(8)//window默认8，linux默认4
struct S
{
    char a;//起始偏移0->0
    int b;//偏移min(8,4)=4->0XXX0000
    short c;//偏移min(8,2)=2(8是2的倍数，不需要补齐)->0xxx|0000|00
    double d;//min(8,8)=8(10不是8的倍数->16->补六位)->0xxx|0000|00xxxxxx|00000000//24
};

class C
{
public:
    char a;
    int b;
    short c;
};//同上，结构体对齐10->12(和长度最长成员的对齐)

int main()
{
    S s;
    C c;
    printf("%x\n", &s.a);
    printf("%x\n", &s.b);
    printf("%x\n", &s.c);
    printf("%x\n", &s.d);
    printf("%x\n", &c.a);
    printf("%x\n", &c.b);
    printf("%x\n", &c.c);
    cout << sizeof(s) << endl;
    cout << sizeof(c) << endl;
    cout << sizeof(s.a) << endl;
    cout << sizeof(s.b) << endl;
    cout << sizeof(s.c) << endl;
    cout << sizeof(s.d) << endl;
    cout << sizeof(double) << endl;

    return 0;
```
**windows debug 86**
```
10ff7d8
10ff7dc
10ff7e0
10ff7e8
10ff7c4
10ff7c8
10ff7cc
24
12
1
4
2
8
8
```
**#pragma pack(4)** ,
**windows debug 86**
```
f5fadc
f5fae0
f5fae4
f5fae8
f5fac8
f5facc
f5fad0
20
12
1
4
2
8
8
```

#pragma pack(1)即各变量内存总和


结构体内的数组(如int a[10])可以认为连续有10个int的变量。
```c
#pragma pack(8)
struct test {
	int a;//0->4
	char b;//4->1
	short c;//6->2
	char d[17];//8->16+1=25
};//25补上3个字节后是min(8,int)的倍数 28
```